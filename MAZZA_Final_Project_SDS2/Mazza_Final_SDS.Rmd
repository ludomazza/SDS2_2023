---
title: "<center>Statistical Methods in Data Science - Final Project"
subtitle: "<center>Analysis of Market Valuation Factors in Forbes Companies 2022 - A Bayesian Linear Regression Study"
author: "Ludovica Mazza"
date: "`r Sys.Date()`"
output:
  html_document:
    theme: flatly
    toc: yes
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE}
rm(list=ls())
```

```{r, echo=FALSE, include=FALSE, warning=FALSE}
#Libraries
library(readr)
library(aod)
library(plotly)
library(heatmaply)
library(ggmcmc)
library(ggplot2)
library(plotly)
library(highcharter)
library(lmtest)
library(countrycode)
library(paletteer)
library(dplyr)
library(kableExtra)
library(gridExtra)
library(ggcorrplot)
library(mcmcplots)
library(coda)
library(R2jags)
library(readxl)
library(ggplot2)
library(lattice)
library(corrplot)
library(stats)
library(rstanarm)
library(BAS)
library(scales)
library(rstan)
library(bayesplot)
library(tidyverse)
library(RColorBrewer)
library(reshape2)
```

## Data Overview

### Data description and analysis purposes

The dataset used is a collection of data, found on [Kaggle](https://www.kaggle.com/datasets/shrikrishnaparab/forbes-billionaires-and-companies-2022), that provides detailed information about the top companies listed in Forbes in 2022.

Specifically, the information we have pertains to:

-   **Rank** : represents the position of each company in the ranking of the richest companies.
-   **Global Company** : is the full name of each company, which is uniquely identified by its name.
-   **Country** : indicates the country in which the company is headquartered.
-   **Market Value** : indicates the market capitalization of the company in 2022.
-   **Profits** : indicates the net profits generated by the company during the reference period.
-   **Sales** : represents the company's total income in the year 2022.
-   **Assets** : represents the total value of the company's assets.

The ultimate goal of this project is not to make predictions, but rather to explore the relationship between the predictors and the response variable.
In more detail, we will focus on understanding the main factors that influence the market value of a company.

### Preprocessing

The preprocessing operations include renaming the variables "Global Company" and "Market Value" to "global_company" and "market_value" for simplicity, converting quantitative variables from the character class to the numeric class and checking for the presence of missing values: luckily, none are found.
Additionally, since monetary balances are expressed in different units of measurement, some in billions and others in millions of dollars, it was chosen to convert everything to billions.

The last modification involved the introduction of a new column labeled "continent." This change was implemented because using the "country" variable, which contained 57 different countries, proved to be somewhat complex.
By categorizing companies into continents we have reduced the number of distinct values to just 6.
This adjustment improves the clarity and efficiency of the analysis that will be done soon.

This is how our dataset appears:

```{r, echo=FALSE, warning=FALSE}
# Import Data
forbes_companies_2022 <- read_csv("forbes_companies_2022.csv", col_types = cols(
  rank = col_double(),
  global_company = col_character(),
  country = col_character(),
  sales = col_character(),
  profit = col_character(),
  assets = col_character(),
  market_value = col_character()
))


# Rename the variables for simplicity
forbes_companies_2022 <- forbes_companies_2022 %>%
  rename(global_company = 'global company')
forbes_companies_2022 <- forbes_companies_2022 %>%
  rename(market_value = 'market value')

# Quickly exploring the dataset, we noticed that the quantitative variables are treated as character types. 
# Additionally, monetary values are expressed in different units of measurement, some in millions and others in billions of dollars. Therefore, we standardize everything to the same unit of measurement, which in this case will be billions of dollars.

# Check the class of the quantitative variables
# class(forbes_companies_2022$market_value)
# class(forbes_companies_2022$sales)
# class(forbes_companies_2022$profit)
# class(forbes_companies_2022$assets)

# Convert to numeric class 
profitti <- forbes_companies_2022$profit
profitti <- gsub(",", "", profitti)
vendite <- forbes_companies_2022$sales
vendite <- gsub(",", "", vendite)
beni <- forbes_companies_2022$assets
beni <- gsub(",", "", beni)
valore <- forbes_companies_2022$market_value
valore <- gsub(",", "", valore)

convert_to_numeric <- function(value) {
  if (grepl("B", value)) {
    return(as.numeric(gsub("[B$]", "", value)))  # Rimuovi 'B' e '$', rimane in miliardi
  } else if (grepl("M", value)) {
    return(as.numeric(gsub("[M$]", "", value)) / 1000)  # Rimuovi 'M' e '$', converte in miliardi
  } else {
    return(NA)  # Se non Ã¨ specificato 'B' o 'M', lascia il valore come NA
  }
}

# Trasform all values to the same unit of measurement
profitti_tipo <- sapply(profitti, function(x) ifelse(grepl("B", x), "B", "M"))
vendite_tipo <- sapply(vendite, function(x) ifelse(grepl("B", x), "B", "M"))
beni_tipo <- sapply(beni, function(x) ifelse(grepl("B", x), "B", "M"))
valore_tipo <- sapply(valore, function(x) ifelse(grepl("B", x), "B", "M"))

profitti_numerici <- as.numeric(gsub("[BM$]", "", profitti))
vendite_numerici <- as.numeric(gsub("[BM$]", "", vendite))
beni_numerici <- as.numeric(gsub("[BM$]", "", beni))
valore_numerici <- as.numeric(gsub("[BM$]", "", valore))

profitti_convertiti <- ifelse(profitti_tipo == "B", profitti_numerici, profitti_numerici / 1000)

vendite_convertiti <- ifelse(vendite_tipo == "B", vendite_numerici, vendite_numerici / 1000)

beni_convertiti <- ifelse(beni_tipo == "B", beni_numerici, beni_numerici / 1000)

valore_convertiti <- ifelse(valore_tipo == "B", valore_numerici, valore_numerici / 1000)

forbes_companies_2022$profit=profitti_convertiti
forbes_companies_2022$sales=vendite_convertiti
forbes_companies_2022$assets=beni_convertiti
forbes_companies_2022$market_value=valore_convertiti
forbes_companies_2022 <- forbes_companies_2022[forbes_companies_2022$profit > 0, ]
forbes_companies_2022 <- forbes_companies_2022[forbes_companies_2022$market_value > 0, ]
forbes_companies_2022 <- forbes_companies_2022[forbes_companies_2022$sales > 0, ]
forbes_companies_2022 <- forbes_companies_2022[forbes_companies_2022$assets > 0, ]
# Add continents
continents <- read_excel("continents.xlsx")
continents <- continents %>%
  rename(country = 'Country')
continents <- continents %>%
  rename(continent = 'Continent')
joined_df <- left_join(forbes_companies_2022, continents, by = "country")
forbes_companies_2022$continent = joined_df$continent

# Visualize the new dataset
dati <- forbes_companies_2022
kable(head(dati,3), format = "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                full_width = FALSE, 
                position = "center", 
                latex_options = c("striped", "hold_position"), 
                fixed_thead = TRUE) 
```

## Exploratory Data Analysis

Before we create the model, it's crucial to take a close look at the dataset so that we can understand how the different variables relate to each other.
This will help us decide which ones are most important for our final model.

### Quantitative Variables

Let's start by analyzing the distribution of quantitative variables.

```{r, warning=FALSE, echo=FALSE}
g1 <- ggplot(data = dati, aes(x = market_value)) +
  geom_density(fill = "#D7B5EA") +
  labs(title = "Market Value", x= "market_value") +
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5)) 

g2 <- ggplot(data = dati, aes(x = profit)) +
  geom_density(fill = "#FFC685") +
  labs(title = "Profits", x="profits") +
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5))

g3 <- ggplot(data = dati, aes(x = assets)) +
  geom_density(fill = "#CCE9C3") +
  labs(title = "Assets", x="assets") +
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5))

g4 <- ggplot(data = dati, aes(x = sales)) +
  geom_density(fill = "#99C5E3") +
  labs(title = "Sales", x="sales") +
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5))

grid.arrange(g1, g2, g3, g4, nrow = 2, ncol = 2)

```

As suggested by the [literature](https://www.ecb.europa.eu/pub/pdf/other/ecbmonetaryanalysisen.pdf), it is expected to encounter a high variance in monetary variables.
To address this issue, we apply a logarithmic transformation.

Indeed, the logarithmic transformation is employed for monetary variables to gain significant advantages in financial data analysis: it reduces data variance, making them more stable, promotes linearity in statistical models, simplifying the modeling of complex relationships, and helps align the data with a normal distribution, which is often a critical assumption in many statistical analyses.

As it is intended to show, after the transformation, the variables have a much more smooth distribution.

```{r, echo=FALSE, warning=FALSE}
dati_log <- log(dati[4:7])
dati_log$continent_category=dati$continent_category
dati_log$global_company=dati$global_company
dati_log$continent = dati$continent
```

```{r, echo=FALSE, warning=FALSE}

ga <- ggplot(data = dati_log, aes(x = market_value)) +
  geom_density(fill = "#D7B5EA") +
  labs(title = "Market Value", x= "market_value") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5))

gb <- ggplot(data = dati_log, aes(x = profit)) +
  geom_density(fill = "#FFC685") +
  labs(title = "Profits", x="profits") +
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5))

gc <- ggplot(data = dati_log, aes(x = assets)) +
  geom_density(fill = "#CCE9C3") +
  labs(title = "Assets", x="assets") +
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5))

gd <- ggplot(data = dati_log, aes(x = sales)) +
  geom_density(fill = "#99C5E3") +
  labs(title = "Sales", x="sales") +
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5))

grid.arrange(ga, gb, gc, gd, nrow = 2, ncol = 2)
```

From this point forward, we will use the logarithmic-transformed data.

### Qualitative Variable

In addition to quantitative variables, our dataset also includes a *country* variable, consisting of 57 unique values representing the 57 countries under consideration.
Let's explore how the geographic location of companies influences their market value.

```{r, echo=FALSE, warning=FALSE}
# Calcola la distribuzione della ricchezza per paese
wealth_by_country <- aggregate(forbes_companies_2022$market_value ~ country, data = forbes_companies_2022, FUN = sum)

# Convert country names to ISO-alpha3 codes
wealth_by_country$ISO_alpha3 <- countrycode(wealth_by_country$country, "country.name", "iso3c")

wealth_by_country$log_marketValue <- log(wealth_by_country$`forbes_companies_2022$market_value`)

# Define the number of colors in the palette
num_colors <- 30

# Create the purple colorscale palette
custom_palette <- paletteer_c("grDevices::Temps", num_colors)

# Interpolate colors to create a custom colorscale
colorscale <- list()
for (i in 1:(num_colors-1)) {
  colorscale[[i]] <- list((i-1)/(num_colors-1), custom_palette[i])
}
colorscale[[num_colors]] <- list(1, custom_palette[num_colors])

fig <- plot_ly(wealth_by_country,
               type='choropleth', 
               locations=wealth_by_country$ISO_alpha3, 
               z=wealth_by_country$log_marketValue,
               text=wealth_by_country$country,
               colorscale= colorscale,
               marker = list(line = list(color = "black", width = 0.5)))
fig
```

What immediately jumps to the eye is that the U.S. is where the companies with the highest market value are located, followed by Canada, Australia, and some European and Asian states.
Conversely, companies with lower market values tend to be primarily situated in Africa and South America.
These significant differences between countries suggest that it might also be useful to include geographic location as a variable to be taken into account in our model.

However, considering the large number of countries in the dataset, handling numerous parameters for estimation could pose challenges in terms of interpretation and computational simplicity.
To address this, we will analyze the data at the level of continents.
It's worth noting that we have divided the continent of America into North America and South America due to variations in market value observed between companies located in the northern and southern regions.

```{r, echo=FALSE}
ggplot(dati_log, aes(x = continent, y = market_value, fill = continent)) +
  geom_boxplot() +
  labs(x = "Continent", y = "Market Value") +
  ggtitle("Wealth Distribution by Continent") + 
  theme_minimal() +
  theme(legend.position = "none", plot.title = element_text(hjust = 0.5))
```

The patterns observed at the country level are clearly mirrored when examining market value on a continent-wide scale.

### Outliers

Another aspect worth investigating to enhance the precision of our model is the presence of outliers.

```{r, warning=FALSE, echo=FALSE}
b1 <- ggplot(data = dati_log, aes(x = market_value)) +
  geom_boxplot(fill = "#D7B5EA") +
  labs(title = "Market Value", x="market_value") +
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5))

b2 <- ggplot(data = dati_log, aes(x = profit)) +
  geom_boxplot(fill = "#FFC685") +
  labs(title = "Profit", x="profits") +
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5))

b3 <- ggplot(data = dati_log, aes(x = assets)) +
  geom_boxplot(fill = "#CCE9C3") +
  labs(title = "Assets", x="assets") +
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5))

b4 <- ggplot(data = dati_log, aes(x = sales)) +
  geom_boxplot(fill = "#99C5E3") +
  labs(title = "Sales", x="sales") +
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5))

grid.arrange(b1, b2, b3, b4, nrow = 2, ncol = 2)

```

Due to the presence of numerous outliers, what we can attempt to do is to consider only the observations that fall between the 5th and the 95th percentile with respect to the response variable.

```{r, echo=FALSE}
percentile_5 <- quantile(dati_log$market_value, 0.1)
percentile_95 <- quantile(dati_log$market_value, 0.9)

# Filtra le osservazioni
data_filtrato <- dati_log[dati_log$market_value >= percentile_5 & dati_log$market_value <= percentile_95, ]
```

```{r, warning=FALSE, echo=FALSE}

b1 <- ggplot(data = data_filtrato, aes(x = market_value)) +
  geom_boxplot(fill = "#D7B5EA") +
  labs(title = "Market Value", x="market_value") +
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5))

b2 <- ggplot(data = data_filtrato, aes(x = profit)) +
  geom_boxplot(fill = "#FFC685") +
  labs(title = "Profit", x="profits") +
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5))

b3 <- ggplot(data = data_filtrato, aes(x = assets)) +
  geom_boxplot(fill = "#CCE9C3") +
  labs(title = "Assets", x="assets") +
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5))

b4 <- ggplot(data = data_filtrato, aes(x = sales)) +
  geom_boxplot(fill = "#99C5E3") +
  labs(title = "Sales", x="sales") +
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5))

grid.arrange(b1, b2, b3, b4, nrow = 2, ncol = 2)
```

The situation appears to have improved slightly.
However, the conclusion from this outlier analysis is that it's not the same company having anomalous values for all variables: a company that appears as an outlier for its market value is not the same one that appears as an outlier for its profits, and this pattern holds for all other variables as well.
Therefore, let's remove only those outliers related to market value.

### Correlation

```{r, echo=FALSE, warning=FALSE, include=FALSE}

numeric_vars <- c("market_value", "profit", "assets", "sales")
numeric_data <- dati[numeric_vars]

dati.cor <- cor(numeric_data)

corr_melted <- melt(dati.cor, varnames = c("row", "column"))

```

```{r, echo=FALSE}
g=ggplot(data = corr_melted, aes(x = row, y = column, fill = value)) +
  geom_tile(color = "white") +
  scale_fill_gradientn(colours = brewer.pal(5, "Purples")) +
  theme_minimal() +
  labs(title = "Correlation Heatmap") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title = element_blank(),
        plot.title = element_text(hjust = 0.5))
gg=ggplotly(g);gg
```

This correlation matrix suggests that profit exhibits a quite strong positive correlation with the market value of companies, in contrast to assets, which appear to be the least correlated variable.
As for sales, there is a moderate correlation.
However, although the correlation between the independent and response variables is a good indicator of a potential relationship, it is not sufficient to determine which variables to include or exclude from the model.
Therefore, it would still be reasonable to start with a complete model that includes all variables.

### Scatter Plot

The final aspect we examine before selecting the ultimate model is the relationship between the response variable and quantitative variables modeled through scatterplots.

```{r, warning=FALSE, echo=FALSE, message = FALSE}

s1 = ggplot(dati_log, aes(x = profit, y = market_value)) +
  geom_point(color = "#FFC685", alpha = 0.5) +
  geom_smooth(method = "lm", se = FALSE, color = "orange") +
  labs(x = "Profit", y = "Market Value", title = "Profit vs Market Value")+
  theme(plot.title = element_text(hjust = 0.5))

s2 = ggplot(dati_log, aes(x = assets, y = market_value)) +
  geom_point(color = "#CCE9C3", alpha = 0.5) +
  geom_smooth(method = "lm", se = FALSE, color = "darkgreen") +
  labs(x = "Assets", y = "Market Value", title = "Assets vs Market Value")+
  theme(plot.title = element_text(hjust = 0.5))

s3 = ggplot(dati_log, aes(x = sales, y = market_value)) +
  geom_point(color = "#99C5E3", alpha = 0.5) +
  geom_smooth(method = "lm", se = FALSE, color = "blue") +
  labs(x = "Sales", y = "Market Value", title = "Sales vs Market Value")+
  theme(plot.title = element_text(hjust = 0.5))

grid.arrange(s1,s2,s3, ncol=2, nrow=2)

```

Upon observing the scatterplots, it becomes evident that for all the quantitative variables that exists a more or less strong linear relationship with the "market value" variable.
This reaffirms our initial observations when inspecting the correlation matrix.

After thoroughly analyzing the data and observed a linear relationship with the response variable, it could be appropriate to consider employing a linear model.

## Frequentist vs Bayesian Linear Regression

Linear regression is a statistical technique widely used to model the relationship between a dependent variable,$Y$, and one or more independent variables $X_{1},...,X_{n}$.
In traditional linear regression, the goal is to estimate model parameters as point estimates.
The fundamental assumption is that the response variable $y$ is a linear combination of a set of predictor variables $X$ and weights $\beta$, with the presence of a random error component $\epsilon$ :

$y = \beta^{T}X + \epsilon$

$\epsilon \sim N(0, \sigma^2)$

The determination of the optimal weights, denoted as $\hat{\beta}$, centers around minimizing the Residual Sum of Squares (RSS).
This optimization technique, commonly known as Ordinary Least Squares (OLS), aims to minimize the sum of squares of the differences between the observed $y$-values and the predicted $\hat{y}$-values and provides a closed-form solution given by the equation:

$\hat{\beta}=(X^{T}X)^{-1}X^Ty$

However, this method lacks a natural way to account for uncertainty in these estimates.

Bayesian linear regression, on the other hand, offers a powerful alternative by treating model parameters as probability distributions.

The Bayesian approach lacks the fundamental assumption of the frequentist approach, that the data inherently contains sufficient information to accurately estimate the coefficients.
Conversely, information is added from a prior probability distribution about the parameters to be estimated: this implies that we will no longer rely on a point estimate of the parameters, but integrate uncertainty into this new model in the form of a probability distribution.

More precisely, we maintain the linear relationship between predictors and their corresponding weights, but in this case, we regard the response variable as:

$Y\sim N(\beta^{T}X,\sigma^{2}I)$

Thus, the goal of this approach is to identify the posterior distribution of weights based on the prior probability distribution assigned to them.

But, how to choose the correct priors?

Usually, there are two potential options to consider.
The first approach involves utilizing parameter-specific prior distributions for the parameters, possibly drawing from prior knowledge found in existing literature or specialized papers related to the subject matter.
The second approach, as extensively discussed by [Andrew Gelman](https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations), implies the use of general prior distributions, commonly referred to as *uninformative priors*.

Because there is no adequate literature about this topic to make this decision, weakly informative priors were chosen, as recommended by Gelman's paper in case *"there's a reasonably large amount of data, so the likelihood will dominate, and the prior will not be so important"*.

After this brief introduction, we have gathered the essential information required to construct and compare our models.

Remind that in constructing our models we use logarithmic-transformed outlier-free data to strive for the most accurate estimation possible.

### Frequentist Approach

#### Model 1: complete

The first model includes all the variables.

```{r}
mod1 = lm(market_value ~ sales + profit + assets + continent, data = dati_log)
summary(mod1)
```

From an initial analysis of this model, what is striking is the almost absence of significance of the 'continent' variable.
Therefore, let's proceed to create a second model that considers only the quantitative variables, and then we will compare the results.

```{r, echo=FALSE}
covariates1 <- model.matrix(mod1)
colnames <- c(
  "(Intercept)","sales","profit","assets",
  "continentAsia","continentEurope","continentNorthAmerica","continentOceania","continentSouthAmerica" )
colnames(covariates1) <- colnames
```

#### Model 2: quantitative variables

Let's include only the quantitative variables.

```{r}
mod2 = lm(market_value ~ sales + profit + assets, data = dati_log)
summary(mod2)
```

To compare the results, we consider various key metrics to assess their goodness.

```{r,echo=FALSE}
covariates2 <- model.matrix(mod2)
```

Regarding the Residual Standard Error, both models have relatively low values, although in the first case, it is slightly lower, suggesting better data adherence to the model.

Moving on to the R-squared, the first model has higher R-squared and Adjusted R-squared values, indicating a better ability to explain the variation in the response variable.
However, this result was expected, as R-squared tends to decrease when the number of predictors used is reduced.

Finally, analyzing the F-statistic, what we deduce is that the second model, which has a significantly higher F-statistic value, is globally more significant.

Certainly, the choice of the best model depends on the objectives and the preference for model complexity.
To get a clearer picture of the situation, let's repeat the analysis using the Bayesian approach.

### Bayesian Approach

#### Model 1: complete

```{r}
# Step 1: Define the model 
# First model: we're using the log_quantitative_variables + we're including the variable continent + we're considering the dataset without the outliers for the response variable market_value
set.seed(12)

lm1 = function(){
  
    # Likelihood:
    for (i in 1:N){
      
    market_value[i] ~ dnorm(mu[i], tau)
      
    mu[i] = alpha + beta_profit * profit[i] + beta_sales * sales[i] + beta_assets * assets[i] + beta_asia * continentAsia[i] + beta_europe * continentEurope[i] + beta_northAmerica * continentNorthAmerica[i] + beta_oceania*continentOceania[i] + beta_southAmerica * continentSouthAmerica[i] }
  
  # Priors:
  alpha ~ dnorm(0, 0.1)
  beta_profit ~ dnorm(0, 0.1)
  beta_sales ~ dnorm(0, 0.1)
  beta_assets ~ dnorm(0, 0.1)
  beta_asia ~ dnorm(0, 0.1)
  beta_europe ~ dnorm(0, 0.1)
  beta_northAmerica ~ dnorm(0, 0.1)
  beta_oceania ~ dnorm(0, 0.1)
  beta_southAmerica ~ dnorm(0, 0.1)
  
  tau ~ dgamma(0.01, 0.01)
  sigma = 1/sqrt(tau)
}

# Step 2: Choose the parameters to save
par1 <- c("alpha",
  "beta_profit",
  "beta_sales", 
  "beta_assets",
  "beta_asia",
  "beta_europe",
  "beta_northAmerica",
  "beta_oceania",
  "beta_southAmerica",
  "tau")

# Step 3: Define the data 
data1 <- list(
  N = nrow(data_filtrato),
  market_value = data_filtrato$market_value,
  profit = covariates1[, "profit"],
  sales = covariates1[, "sales"],
  assets = covariates1[, "assets"],
  continentAsia = covariates1[, "continentAsia"],
  continentEurope = covariates1[, "continentEurope"],
  continentNorthAmerica = covariates1[, "continentNorthAmerica"],
  continentSouthAmerica = covariates1[, "continentSouthAmerica"],
  continentOceania = covariates1[, "continentOceania"]
)

# Step4: Run the model 
fit1 <- jags(
  data = data1, 
  inits = NULL, 
  parameters.to.save = par1, 
  model.file = lm1,
  n.chains = 3, 
  n.iter = 10000, 
  n.burnin = 1000, 
  n.thin = 1, 
  DIC = TRUE,
  quiet = TRUE
)

fit1
```

Despite the apparent convergence, we immediately notice that the parameters related to the 'continent' variable are very close to zero, indicating their lack of significance for the model.
Therefore, let's construct a second model that only considers the quantitative variables, following the same approach as we did in the frequentist analysis.

```{r,echo=FALSE}
# salviamoci il DIC di questo modello
DIC_completo_wo= fit1$BUGSoutput$DIC
```

#### Model 2: quantitative variables

```{r}
# Step 1: Define the model 
# Second model: we're using the log_quantitative_variables + we're considering the dataset without the outliers for the response variable market_value 
set.seed(12)
lm2 = function(){
  
    # Likelihood:
    for (i in 1:N){
      
    market_value[i] ~ dnorm(mu[i], tau)
      
    mu[i] = alpha + beta_profit * profit[i] + beta_sales * sales[i] + beta_assets*assets[i]}
  
  # Priors:
  alpha ~ dnorm(0, 0.1)
  beta_profit ~ dnorm(0, 0.1)
  beta_sales ~ dnorm(0, 0.1)
  beta_assets ~ dnorm(0, 0.1)
  
  tau ~ dgamma(0.1, 0.1)
  sigma = 1/sqrt(tau)
}

# Step 2: Choose the parameters to save
par2 <- c("alpha",
  "beta_profit",
  "beta_sales", 
  "beta_assets",
  "tau")

# Step 3: Define the data 
data2 <- list(
  N = nrow(data_filtrato),
  market_value = data_filtrato$market_value,
  profit = covariates2[, "profit"],
  sales = covariates2[, "sales"],
  assets = covariates2[, "assets"])

# Step4: Run the model 
fit2 <- jags(
  data = data2, 
  inits = NULL, 
  parameters.to.save = par2, 
  model.file = lm2,
  n.chains = 3, 
  n.iter = 10000, 
  n.burnin = 1000, 
  n.thin = 1, 
  DIC = TRUE,
  quiet = TRUE
)

fit2
```

```{r,echo=FALSE}
# salviamoci il DIC per questo secondo modello
DIC_quant_wo= fit2$BUGSoutput$DIC
```

It's evident, by looking at the DIC, that this second model is better than the previous one.

The DIC, or Deviance Information Criterion, is a statistical measure used in Bayesian model comparison and selection and serves as a tool to assess the goodness-of-fit and predictive performance of different models, particularly in the context of Bayesian analysis.
It is based on the concept of "deviance," which is a measure of how well a statistical model explains the observed data: lower deviance values indicate that a model fits the data better, capturing the underlying patterns and relationships more effectively.

The construction of the DIC takes into account two aspects:

1.  Model Fit (pD): This part evaluates how well the model fits observed data while considering its complexity.
    It penalizes models with excessive parameters that might overfit while impler models with fewer parameters are favored if they adequately explain the data.

2.  Predictive Performance (the actual DIC): The DIC value combines the deviance and pD to estimate the model's expected predictive error and indicates how well the model is likely to perform when making predictions on new, unseen data.
    Lower DIC values indicate better predictive performance.

Of course, relying solely on the DIC is not enough to determine the actual goodness of a model.
Let's proceed to analyze the model diagnostics, which are useful for understanding how much we can trust the obtained estimates.

### Diagnostics

Following with the analysis of the obtained output, we find:

#### R-hat

The Rhat, also known as the Gelman-Rubin statistic, is a measure used to check if the chains have converged sufficiently to estimate the posterior distribution accurately.
An Rhat equal to 1 represents the ideal scenario: it indicates that the chains have converged to the same stationary distribution and that the parameter estimates are reliable.
However, in general, Rhat values below a threshold of 1.05, as in our case, are widely accepted as an indicator of good convergence.

#### N.eff

The "n.eff" or *effective sample size* is a measure used to assess the quality of the (MCMC) samples generated during the estimation process.
In Bayesian analysis, MCMC methods generate a sequence of samples that are not entirely independent due to the autocorrelation between consecutive samples: the n.eff helps quantify the magnitude of this autocorrelation and provides an estimate of how many independent samples you would need from a completely independent distribution to achieve the same level of precision.

As autocorrelation decreases, the ESS increases and the estimates are more precised.

In our case, the effective sample size is equal, for each parameter, to the total number of iterations: in fact we notice how the autocorrelation goes to practically zero already after the first lag.

```{r, echo=FALSE}
par(mfrow = c(2, 3))
a1=acf(fit2$BUGSoutput$sims.array[,2,"alpha"], main = "ACF for alpha", lwd=2)
a2=acf(fit2$BUGSoutput$sims.array[,2,"beta_assets"], main = "ACF for beta_assets", lwd=2)
a3=acf(fit2$BUGSoutput$sims.array[,2,"beta_profit"], main = "ACF for beta_profit", lwd=2)
a4=acf(fit2$BUGSoutput$sims.array[,2,"beta_sales"], main = "ACF for beta_sales", lwd=2)
a5=acf(fit2$BUGSoutput$sims.array[,2,"tau"], main = "ACF for tau", lwd=2)

```

#### Trace Plots

A traceplot is a graphical representation commonly employed in Markov Chain Monte Carlo (MCMC) analysis to visualize how chains behave when sampling statistical parameters.
Its primary purpose is to track the evolution of these chains over time, providing insights into potential convergence problems.

The desired result is that the chains within each traceplot show stability (converging around a single value) and good mixing (all chains overlap closely around the same value).

What does this means?

Convergence refers to the property whereby MCMC chains eventually stabilize in a stationary distribution.
In other words, they reach a point where their values no longer change significantly from one iteration to the next.
Stability means that the chains have actually explored and found the central tendency or most likely value of the parameter to be estimated.

Mixture, on the other hand, refers to the effectiveness with which the MCMC chains explore the entire parameter space: if the chains are well mixed, it means that they move freely and explore different regions of the parameter space, which is essential for obtaining accurate estimates.

When all chains overlap around the same value, it means they have reached a common point of convergence and provide consistent estimates.

```{r,echo=FALSE}
mcmcplots::traplot(fit2, parms = par2)
```

Looking at our result we can see that all the points developed above are perfectly met.

#### Density Plots

In addition to the traceplot, another valuable tool frequently employed is the density plot, which offers insights into the probability distribution of the estimated parameters.

When examining a density plot, if the peak of the curve is far from zero and is well-defined, it suggests that the parameter estimate is likely to be concentrated around that value with low uncertainty.

```{r,echo=FALSE}
mcmcplots::denplot(fit2, parms = par2)
```

In this context, the immediate observation of all three chains converging to a normal distribution with a defined peak confirms the significance of the relationships between the coefficients highlighted in the traceplots above.
Also, it can be seen that no parameter takes on a range of values that includes zero.

### DIC comparison

The choice of the two models described above was the result of several attempts.
Given the specific situation we encountered with the outliers and the asymmetric distribution of the monetary variables, the decision was made to use the dataset with logarithmic transformations and without outliers regarding the response variable.

We are now reproducing the same models using both the original dataset and the dataset containing all observations (including outliers) to make sure that the choices made are correct.

```{r, echo=FALSE}
mod3 = lm(market_value ~ sales + profit + assets + continent, data = dati)
```

```{r, echo=FALSE}
covariates3 <- model.matrix(mod3)
colnames <- c(
  "(Intercept)","sales","profit","assets",
  "continentAsia","continentEurope","continentNorthAmerica","continentOceania","continentSouthAmerica" )
colnames(covariates3) <- colnames
```

```{r, echo=FALSE}
# Step 1: Define the model 
# Third model: complete + initial data
lm3 = function(){
  
    # Likelihood:
    for (i in 1:N){
      
    market_value[i] ~ dnorm(mu[i], tau)
      
    mu[i] = alpha + beta_profit * profit[i] + beta_sales * sales[i] + beta_assets * assets[i] + beta_asia * continentAsia[i] + beta_europe * continentEurope[i] + beta_northAmerica * continentNorthAmerica[i] + beta_oceania*continentOceania[i] + beta_southAmerica * continentSouthAmerica[i] }
  
  # Priors:
  alpha ~ dnorm(0, 0.1)
  beta_profit ~ dnorm(0, 0.1)
  beta_sales ~ dnorm(0, 0.1)
  beta_assets ~ dnorm(0, 0.1)
  beta_asia ~ dnorm(0, 0.1)
  beta_europe ~ dnorm(0, 0.1)
  beta_northAmerica ~ dnorm(0, 0.1)
  beta_oceania ~ dnorm(0, 0.1)
  beta_southAmerica ~ dnorm(0, 0.1)
  
  tau ~ dgamma(0.1, 0.1)
  sigma = 1/sqrt(tau)
}

# Step 2: Choose the parameters to save
par3 <- c("alpha",
  "beta_profit",
  "beta_sales", 
  "beta_assets",
  "beta_asia",
  "beta_europe",
  "beta_northAmerica",
  "beta_oceania",
  "beta_southAmerica",
  "tau")

# Step 3: Define the data 
data3 <- list(
  N = nrow(dati),
  market_value = dati$market_value,
  profit = covariates3[, "profit"],
  sales = covariates3[, "sales"],
  assets = covariates3[, "assets"],
  continentAsia = covariates3[, "continentAsia"],
  continentEurope = covariates3[, "continentEurope"],
  continentNorthAmerica = covariates3[, "continentNorthAmerica"],
  continentSouthAmerica = covariates3[, "continentSouthAmerica"],
  continentOceania = covariates3[, "continentOceania"]
)


# Step5: Run the model 
fit3 <- jags(
  data = data3, 
  inits = NULL, 
  parameters.to.save = par3, 
  model.file = lm3,
  n.chains = 3, 
  n.iter = 10000, 
  n.burnin = 1000, 
  n.thin = 1, 
  DIC = TRUE,
  quiet = TRUE
)

DIC_completo = fit3$BUGSoutput$DIC
```

```{r, echo=FALSE}
mod4 = lm(market_value ~ sales + profit + assets, data = dati)
covariates4 <- model.matrix(mod4)
```

```{r, echo=FALSE}
# Step 1: Define the model 
# Quant + inital data
lm4 = function(){
  
    # Likelihood:
    for (i in 1:N){
      
    market_value[i] ~ dnorm(mu[i], tau)
      
    mu[i] = alpha + beta_profit * profit[i] + beta_sales * sales[i] + beta_assets*assets[i]}
  
  # Priors:
  alpha ~ dnorm(0, 0.01)
  beta_profit ~ dnorm(0, 0.01)
  beta_sales ~ dnorm(0, 0.01)
  beta_assets ~ dnorm(0, 0.01)
  
  tau ~ dgamma(0.001, 0.001)
  sigma = 1/sqrt(tau)
}

# Step 2: Choose the parameters to save
par4 <- c("alpha",
  "beta_profit",
  "beta_sales", 
  "beta_assets",
  "tau")

# Step 4: Define the data 
data4 <- list(
  N = nrow(dati),
  market_value = dati$market_value,
  profit = covariates4[, "profit"],
  sales = covariates4[, "sales"],
  assets = covariates4[, "assets"])

# Step5: Run the model 
fit4 <- jags(
  data = data4, 
  inits = NULL, 
  parameters.to.save = par4, 
  model.file = lm4,
  n.chains = 3, 
  n.iter = 10000, 
  n.burnin = 1000, 
  n.thin = 1, 
  DIC = TRUE,
  quiet = TRUE
)

DIC_Quant=fit4$BUGSoutput$DIC
```

```{r, echo=FALSE}
mod5 = lm(market_value ~ sales + profit + assets + continent, data = dati_log)
```

```{r, echo=FALSE}
covariates5 <- model.matrix(mod5)
colnames <- c(
  "(Intercept)","sales","profit","assets",
  "continentAsia","continentEurope","continentNorthAmerica","continentOceania","continentSouthAmerica" )
colnames(covariates5) <- colnames
```

```{r, echo=FALSE}
# Step 1: Define the model 
# Complete + log data
lm5 = function(){
  
    # Likelihood:
    for (i in 1:N){
      
    market_value[i] ~ dnorm(mu[i], tau)
      
    mu[i] = alpha + beta_profit * profit[i] + beta_sales * sales[i] + beta_assets * assets[i] + beta_asia * continentAsia[i] + beta_europe * continentEurope[i] + beta_northAmerica * continentNorthAmerica[i] + beta_oceania*continentOceania[i] + beta_southAmerica * continentSouthAmerica[i] }
  
  # Priors:
  alpha ~ dnorm(0, 0.01)
  beta_profit ~ dnorm(0, 0.01)
  beta_sales ~ dnorm(0, 0.01)
  beta_assets ~ dnorm(0, 0.01)
  beta_asia ~ dnorm(0, 0.01)
  beta_europe ~ dnorm(0, 0.01)
  beta_northAmerica ~ dnorm(0, 0.01)
  beta_oceania ~ dnorm(0, 0.01)
  beta_southAmerica ~ dnorm(0, 0.01)
  
  tau ~ dgamma(0.001, 0.001)
  sigma = 1/sqrt(tau)
}

# Step 2: Choose the parameters to save
par5 <- c("alpha",
  "beta_profit",
  "beta_sales", 
  "beta_assets",
  "beta_asia",
  "beta_europe",
  "beta_northAmerica",
  "beta_oceania",
  "beta_southAmerica",
  "tau")

# Step 3: Define the data 
data5 <- list(
  N = nrow(dati_log),
  market_value = dati_log$market_value,
  profit = covariates5[, "profit"],
  sales = covariates5[, "sales"],
  assets = covariates5[, "assets"],
  continentAsia = covariates5[, "continentAsia"],
  continentEurope = covariates5[, "continentEurope"],
  continentNorthAmerica = covariates5[, "continentNorthAmerica"],
  continentSouthAmerica = covariates5[, "continentSouthAmerica"],
  continentOceania = covariates5[, "continentOceania"]
)

# Step5: Run the model 
fit5 <- jags(
  data = data5, 
  inits = NULL, 
  parameters.to.save = par5, 
  model.file = lm5,
  n.chains = 3, 
  n.iter = 10000, 
  n.burnin = 1000, 
  n.thin = 1, 
  DIC = TRUE,
  quiet = TRUE
)

DIC_completo_log = fit5$BUGSoutput$DIC
```

```{r, echo=FALSE}
mod6 = lm(market_value ~ sales + profit + assets, data = dati_log)
covariates6 <- model.matrix(mod6)
```

```{r, echo=FALSE}
# Step 1: Define the model 
# Quant + log data
lm6 = function(){
  
    # Likelihood:
    for (i in 1:N){
      
    market_value[i] ~ dnorm(mu[i], tau)
      
    mu[i] = alpha + beta_profit * profit[i] + beta_sales * sales[i] + beta_assets*assets[i]}
  
  # Priors:
  alpha ~ dnorm(0, 0.01)
  beta_profit ~ dnorm(0, 0.01)
  beta_sales ~ dnorm(0, 0.01)
  beta_assets ~ dnorm(0, 0.01)
  
  tau ~ dgamma(0.001, 0.001)
  sigma = 1/sqrt(tau)
}

# Step 2: Choose the parameters to save
par6 <- c("alpha",
  "beta_profit",
  "beta_sales", 
  "beta_assets",
  "tau")

# Step 4: Define the data 
data6 <- list(
  N = nrow(dati_log),
  market_value = dati_log$market_value,
  profit = covariates6[, "profit"],
  sales = covariates6[, "sales"],
  assets = covariates6[, "assets"])

# Step5: Run the model 
fit6 <- jags(
  data = data6, 
  inits = NULL, 
  parameters.to.save = par6, 
  model.file = lm6,
  n.chains = 3, 
  n.iter = 10000, 
  n.burnin = 1000, 
  n.thin = 1, 
  DIC = TRUE,
  quiet = TRUE
)

DIC_Quant_Log=fit6$BUGSoutput$DIC
```

```{r,echo=FALSE}
model_data <- data.frame(
  Modello = c("Compl_wo", "Quant_wo", "Complete", "Quant","Compl_log", "Quant_log"),
  DIC = c(DIC_completo_wo, DIC_quant_wo, DIC_completo,DIC_Quant,DIC_completo_log,DIC_Quant_Log) 
)
```

```{r,echo=FALSE}
# Crea il barplot con ggplot2
m=ggplot(data = model_data, aes(x = Modello, y = DIC, fill = Modello)) +
  geom_bar(stat = "identity") +
  labs(title = "DIC Comparison", x = "Fit", y = "DIC Value") +
  theme_minimal()
mm=ggplotly(m);mm
```

By comparing the DIC values of the models, we can see how the modifications made to the initial dataset have indeed proven to be correct.
